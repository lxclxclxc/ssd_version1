		Session.vim	/^nnoremap <buffer> 	 :call search('\\[[0-9]*:[^\\]]*\\]')$/;"	m
	Session.vim	/^nnoremap <buffer>  :WinManagerGotoNextInGroup "FileExplorer"$/;"	m
	Session.vim	/^nnoremap <buffer>  :WinManagerGotoNextInGroup "TagList"$/;"	m
	Session.vim	/^nnoremap <buffer>  :WinManagerGotoPrevInGroup "FileExplorer"$/;"	m
	Session.vim	/^nnoremap <buffer>  :WinManagerGotoPrevInGroup "TagList"$/;"	m
	Session.vim	/^nmap  :BottomExplorerWindow$/;"	m
	Session.vim	/^nmap  :FirstExplorerWindow$/;"	m
	Session.vim	/^nnoremap <buffer>  <Nop>$/;"	m
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
*	Session.vim	/^inoremap <buffer> <silent> * :silent! %foldopen!$/;"	m
*	Session.vim	/^nnoremap <buffer> <silent> * :silent! %foldopen!$/;"	m
+	Session.vim	/^inoremap <buffer> <silent> + :silent! foldopen$/;"	m
+	Session.vim	/^nnoremap <buffer> <silent> + :silent! foldopen$/;"	m
-	Session.vim	/^inoremap <buffer> <silent> - :silent! foldclose$/;"	m
-	Session.vim	/^nnoremap <buffer> <silent> - :silent! foldclose$/;"	m
0	Session.vim	/^normal! 0$/;"	m
095|	Session.vim	/^normal! 095|$/;"	m
<Down>	Session.vim	/^nnoremap <buffer> <Down> gj$/;"	m
<F4>	Session.vim	/^map <F4> :WMToggle$/;"	m
<Plug>NetrwBrowseX	Session.vim	/^nnoremap <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(expand((exists("g:netrw_gx")? g:netrw_gx : '<cfile>')),netrw#CheckIfRemote())$/;"	m
<Plug>NetrwBrowseXVis	Session.vim	/^vnoremap <silent> <Plug>NetrwBrowseXVis :call netrw#BrowseXVis()$/;"	m
<S-Tab>	Session.vim	/^nnoremap <buffer> <S-Tab> :call search('\\[[0-9]*:[^\\]]*\\]','b')$/;"	m
<Up>	Session.vim	/^nnoremap <buffer> <Up> gk$/;"	m
<kMinus>	Session.vim	/^inoremap <buffer> <silent> <kMinus> :silent! foldclose$/;"	m
<kMinus>	Session.vim	/^nnoremap <buffer> <silent> <kMinus> :silent! foldclose$/;"	m
<kMultiply>	Session.vim	/^inoremap <buffer> <silent> <kMultiply> :silent! %foldopen!$/;"	m
<kMultiply>	Session.vim	/^nnoremap <buffer> <silent> <kMultiply> :silent! %foldopen!$/;"	m
<kPlus>	Session.vim	/^inoremap <buffer> <silent> <kPlus> :silent! foldopen$/;"	m
<kPlus>	Session.vim	/^nnoremap <buffer> <silent> <kPlus> :silent! foldopen$/;"	m
=	Session.vim	/^inoremap <buffer> <silent> = :silent! %foldclose$/;"	m
=	Session.vim	/^nnoremap <buffer> <silent> = :silent! %foldclose$/;"	m
ACTIVE_ADJUST	initialize.c	29;"	d	file:
ACTIVE_FIXED	initialize.c	28;"	d	file:
AD_COPYBACK	initialize.h	43;"	d
AD_INTERLEAVE	initialize.h	45;"	d
AD_RANDOM	initialize.h	42;"	d
AD_TWOPLANE	initialize.h	44;"	d
AD_TWOPLANE_READ	initialize.h	46;"	d
AVLTREE_H	avlTree.h	2;"	d
AVL_NULL	avlTree.h	8;"	d
AVL_TREENODE_FREE	avlTree.c	/^void AVL_TREENODE_FREE$/;"	f
AVL_TREE_LOCK	avlTree.c	/^void AVL_TREE_LOCK$/;"	f
AVL_TREE_UNLOCK	avlTree.c	/^void AVL_TREE_UNLOCK$/;"	f
BLOKC	initialize.h	110;"	d
BUFSIZE	initialize.h	30;"	d
CHANNEL	initialize.h	106;"	d
CHANNEL_C_A_TRANSFER	initialize.h	58;"	d
CHANNEL_DATA_TRANSFER	initialize.h	64;"	d
CHANNEL_GC	initialize.h	59;"	d
CHANNEL_GC_ERASE	initialize.h	61;"	d
CHANNEL_IDLE	initialize.h	57;"	d
CHANNEL_TRANSFER	initialize.h	65;"	d
CHANNEL_UNKNOWN	initialize.h	66;"	d
CHIP_COPYBACK_BUSY	initialize.h	79;"	d
CHIP_C_A_TRANSFER	initialize.h	71;"	d
CHIP_DATA_TRANSFER	initialize.h	76;"	d
CHIP_ERASE_BUSY	initialize.h	78;"	d
CHIP_GC_RW_BUSY	initialize.h	74;"	d
CHIP_IDLE	initialize.h	68;"	d
CHIP_READ_BUSY	initialize.h	70;"	d
CHIP_WAIT	initialize.h	77;"	d
CHIP_WRITE_BUSY	initialize.h	69;"	d
CHIP_WRITE_DATA_CMD_BUSY	initialize.h	73;"	d
COPY_BACK	initialize.h	40;"	d
DYNAMIC_ALLOCATION	initialize.h	32;"	d
Dram_write_map	initialize.h	/^typedef struct Dram_write_map {$/;"	s
Dram_write_map	initialize.h	/^} Dram_write_map;$/;"	t	typeref:struct:Dram_write_map
EH_FACTOR	avlTree.h	10;"	d
ERROR	initialize.h	124;"	d
FAILURE	initialize.h	123;"	d
FALSE	initialize.c	25;"	d	file:
FALSE	initialize.h	121;"	d
FLASH_H	flash.h	20;"	d
GC_COMPLETE	initialize.h	102;"	d
GC_COPY_BACK	initialize.h	101;"	d
GC_ERASE_C_A	initialize.h	100;"	d
GC_INTERRUPT	initialize.h	103;"	d
GC_UNINTERRUPT	initialize.h	104;"	d
GC_WAIT	initialize.h	99;"	d
INFEASIBLE	initialize.h	125;"	d
INITIALIZE_H	initialize.h	19;"	d
INSERT_NEXT	avlTree.h	20;"	d
INSERT_PREV	avlTree.h	19;"	d
INTERLEAVE	initialize.h	35;"	d
INTERLEAVE_TWO_PLANE	initialize.h	39;"	d
LEFT_MINUS	avlTree.h	13;"	d
LH_FACTOR	avlTree.h	11;"	d
LRU_link_next	initialize.h	/^    struct buffer_group *LRU_link_next;    \/\/ next node in LRU list$/;"	m	struct:buffer_group	typeref:struct:buffer_group::buffer_group
LRU_link_pre	initialize.h	/^    struct buffer_group *LRU_link_pre;    \/\/ previous node in LRU list$/;"	m	struct:buffer_group	typeref:struct:buffer_group::buffer_group
L_Rotate	avlTree.c	/^static void L_Rotate(TREE_NODE **ppNode) {$/;"	f	file:
LeftBalance	avlTree.c	/^static void LeftBalance(TREE_NODE **ppNode) {$/;"	f	file:
MAX_INT64	pagemap.h	24;"	d
MAX_INT64	ssd.h	27;"	d
NORMAL	initialize.h	38;"	d
ORDER_LIST_WANTED	avlTree.h	17;"	d
OUTPUT	initialize.h	97;"	d
OVERFLOW	initialize.h	126;"	d
PAGE	initialize.h	111;"	d
PAGEMAP_H	pagemap.h	19;"	d
PG_SUB	initialize.h	114;"	d
PLANE	initialize.h	109;"	d
READ	initialize.h	48;"	d
REQUEST_IN	initialize.h	96;"	d
RH_FACTOR	avlTree.h	12;"	d
RIGHT_MINUS	avlTree.h	14;"	d
R_Rotate	avlTree.c	/^static void R_Rotate(TREE_NODE **ppNode) {$/;"	f	file:
RightBalance	avlTree.c	/^static void RightBalance(TREE_NODE **ppNode) {$/;"	f	file:
SECTOR	initialize.h	29;"	d
SR_COMPLETE	initialize.h	94;"	d
SR_R_C_A_TRANSFER	initialize.h	83;"	d
SR_R_DATA_TRANSFER	initialize.h	85;"	d
SR_R_READ	initialize.h	84;"	d
SR_WAIT	initialize.h	82;"	d
SR_W_C_A_DATA_TRANSFER	initialize.h	86;"	d
SR_W_DATA_TRANSFER	initialize.h	92;"	d
SR_W_DATA_TRANSFER_ONE_PROG_OF_ITERATIONS	initialize.h	87;"	d
SR_W_DATA_TRANSFER_ONE_VERIFY_OF_ITERATIONS	initialize.h	88;"	d
SR_W_TRANSFER	initialize.h	89;"	d
STATIC_ALLOCATION	initialize.h	33;"	d
SUBPAGE	initialize.h	112;"	d
SUCCESS	initialize.h	122;"	d
SessionLoad	Session.vim	/^let SessionLoad = 1$/;"	v
Status	initialize.h	/^typedef int Status;$/;"	t
TREE_NODE	avlTree.h	/^} TREE_NODE;$/;"	t	typeref:struct:_AVL_TREE_NODE
TRUE	initialize.c	26;"	d	file:
TRUE	initialize.h	120;"	d
TWO_PLANE	initialize.h	36;"	d
UNKNOWN	initialize.h	80;"	d
WRITE	initialize.h	49;"	d
\mbc	Session.vim	/^map \\mbc <Plug>CMiniBufExplorer$/;"	m
\mbe	Session.vim	/^map \\mbe <Plug>MiniBufExplorer$/;"	m
\mbt	Session.vim	/^map \\mbt <Plug>TMiniBufExplorer$/;"	m
\mbu	Session.vim	/^map \\mbu <Plug>UMiniBufExplorer$/;"	m
_AVL_TREE_NODE	avlTree.h	/^typedef struct _AVL_TREE_NODE {$/;"	s
_CRTDBG_MAP_ALLOC	initialize.c	19;"	d	file:
_CRTDBG_MAP_ALLOC	pagemap.c	19;"	d	file:
ac_time_characteristics	initialize.h	/^struct ac_time_characteristics {$/;"	s
ac_timing	initialize.h	/^    struct ac_time_characteristics ac_timing;$/;"	m	struct:chip_info	typeref:struct:chip_info::ac_time_characteristics
ac_timing	initialize.h	/^} ac_timing;$/;"	v	typeref:struct:ac_time_characteristics
active_block	initialize.h	/^    unsigned int active_block;          \/\/if a die has a active block, è¯¥é¡¹è¡¨ç¤ºå…¶ç‰©ç†å—å·$/;"	m	struct:plane_info
active_current	initialize.h	/^    float active_current;$/;"	m	struct:dram_parameter
active_flag	initialize.h	/^    int active_flag;                     \/\/è®°å½•ä¸»åŠ¨å†™æ˜¯å¦é˜»å¡ï¼Œå¦‚æœå‘ç°æŸ±å¡ï¼Œéœ€è¦å°†æ—¶é—´å‘å‰æ¨è¿›,0è¡¨ç¤ºæ²¡æœ‰é˜»å¡ï¼Œ1è¡¨ç¤ºè¢«é˜»å¡ï¼Œéœ€è¦å‘å‰æ¨è¿›æ—¶é—´$/;"	m	struct:ssd_info
active_write	initialize.h	/^    int active_write;               \/\/è¡¨ç¤ºæ˜¯å¦æ‰§è¡Œä¸»åŠ¨å†™æ“ä½œ1,yes;0,no$/;"	m	struct:parameter_value
ad_priority	initialize.h	/^    int ad_priority;                \/\/record the priority between two plane operation and interleave operation$/;"	m	struct:parameter_value
ad_priority2	initialize.h	/^    int ad_priority2;               \/\/record the priority of channel-level, 0 indicates that the priority order of channel-level is highest; 1 indicates the contrary$/;"	m	struct:parameter_value
add_reg_ppn	initialize.h	/^    int add_reg_ppn;                    \/\/readï¼Œwriteæ—¶æŠŠåœ°å€ä¼ é€åˆ°è¯¥å˜é‡ï¼Œè¯¥å˜é‡ä»£è¡¨åœ°å€å¯„å­˜å™¨ã€‚dieç”±busyå˜ä¸ºidleæ—¶ï¼Œæ¸…é™¤åœ°å€ \/\/æœ‰å¯èƒ½å› ä¸ºä¸€å¯¹å¤šçš„æ˜ å°„ï¼Œåœ¨ä¸€ä¸ªè¯»è¯·æ±‚æ—¶ï¼Œæœ‰å¤šä¸ªç›¸åŒçš„lpnï¼Œæ‰€ä»¥éœ€è¦ç”¨ppnæ¥åŒºåˆ†$/;"	m	struct:plane_info
address_mapping	initialize.h	/^    int address_mapping;            \/\/è®°å½•æ˜ å°„çš„ç±»å‹ï¼Œ1ï¼špageï¼›2ï¼šblockï¼›3ï¼šfast$/;"	m	struct:parameter_value
advanced_commands	initialize.h	/^    int advanced_commands;$/;"	m	struct:parameter_value
after_pre_process_pages_number	initialize.h	/^int after_pre_process_pages_number;$/;"	m	struct:ssd_info
after_pre_processe_and_aged_pages_number	initialize.h	/^int after_pre_processe_and_aged_pages_number;$/;"	m	struct:ssd_info
aged	initialize.h	/^    int aged;                       \/\/1è¡¨ç¤ºéœ€è¦å°†è¿™ä¸ªSSDå˜æˆagedï¼Œ0è¡¨ç¤ºéœ€è¦å°†è¿™ä¸ªSSDä¿æŒnon-aged$/;"	m	struct:parameter_value
aged_ratio	initialize.h	/^    float aged_ratio;$/;"	m	struct:parameter_value
alloc_assert	pagemap.c	/^void alloc_assert(void *p, char *s)\/\/æ–­è¨€$/;"	f
alloc_pool	initialize.h	/^    int alloc_pool;                 \/\/allocation pool å¤§å°(planeï¼Œdieï¼Œchipï¼Œchannel),ä¹Ÿå°±æ˜¯æ‹¥æœ‰active_blockçš„å•ä½$/;"	m	struct:parameter_value
allocate_location	flash.c	/^Status allocate_location(struct ssd_info *ssd, struct sub_request *sub_req) {$/;"	f
allocation_scheme	initialize.h	/^    int allocation_scheme;          \/\/è®°å½•åˆ†é…æ–¹å¼çš„é€‰æ‹©ï¼Œ0è¡¨ç¤ºåŠ¨æ€åˆ†é…ï¼Œ1è¡¨ç¤ºé™æ€åˆ†é…$/;"	m	struct:parameter_value
attach_info	initialize.h	/^    struct buffer_info *attach_info;    \/\/ info about attach map$/;"	m	struct:map_info	typeref:struct:map_info::buffer_info
ave_read_size	initialize.h	/^    float ave_read_size;$/;"	m	struct:ssd_info
ave_write_size	initialize.h	/^    float ave_write_size;$/;"	m	struct:ssd_info
avlDelBalance	avlTree.c	/^static int avlDelBalance$/;"	f	file:
avlTreeAdd	avlTree.c	/^int avlTreeAdd$/;"	f
avlTreeCheck	avlTree.c	/^int avlTreeCheck(tAVLTree *pTree, TREE_NODE *pNode) {$/;"	f
avlTreeCount	avlTree.c	/^unsigned int avlTreeCount$/;"	f
avlTreeCreate	avlTree.c	/^tAVLTree *avlTreeCreate(int *keyCompareFunc, int *freeFunc) {$/;"	f
avlTreeDel	avlTree.c	/^int avlTreeDel(tAVLTree *pTree, TREE_NODE *pDelNode) {$/;"	f
avlTreeDestroy	avlTree.c	/^int avlTreeDestroy$/;"	f
avlTreeFind	avlTree.c	/^TREE_NODE *avlTreeFind$/;"	f
avlTreeFirst	avlTree.c	/^TREE_NODE *avlTreeFirst$/;"	f
avlTreeFlush	avlTree.c	/^int avlTreeFlush$/;"	f
avlTreeHigh	avlTree.c	/^int avlTreeHigh(TREE_NODE *pNode) {$/;"	f
avlTreeInsert	avlTree.c	/^static int avlTreeInsert$/;"	f	file:
avlTreeLast	avlTree.c	/^TREE_NODE *avlTreeLast$/;"	f
avlTreeLookup	avlTree.c	/^static TREE_NODE *avlTreeLookup$/;"	f	file:
avlTreeNext	avlTree.c	/^TREE_NODE *avlTreeNext$/;"	f
avlTreePrev	avlTree.c	/^TREE_NODE *avlTreePrev$/;"	f
avlTreeRemove	avlTree.c	/^static int avlTreeRemove$/;"	f	file:
begin_time	initialize.h	/^    int64_t begin_time;               \/\/å­è¯·æ±‚å¼€å§‹æ—¶é—´$/;"	m	struct:sub_request
begin_time	initialize.h	/^    int64_t begin_time;            \/\/è®°å½•ä¸€ä¸ªplaneä»€ä¹ˆæ—¶å€™å¼€å§‹gcæ“ä½œçš„$/;"	m	struct:gc_info
begin_time	initialize.h	/^    int64_t begin_time;$/;"	m	struct:request
bf	avlTree.h	/^    int bf;                                     \/*å¹³è¡¡å› å­ï¼›å½“å¹³è¡¡å› å­çš„ç»å¯¹å€¼å¤§äº æˆ–ç­‰äº2çš„æ—¶å€™å°±è¡¨ç¤ºæ ‘ä¸å¹³è¡¡(balance_factor)*\/$/;"	m	struct:_AVL_TREE_NODE
blk_head	initialize.h	/^    struct blk_info *blk_head;$/;"	m	struct:plane_info	typeref:struct:plane_info::blk_info
blk_info	initialize.h	/^struct blk_info {$/;"	s
block	initialize.h	/^    unsigned int block;           \/\/è¯¥å‚æ•°åªåœ¨å¯ä¸­æ–­çš„gcå‡½æ•°ä¸­ä½¿ç”¨ï¼ˆgc_interruptï¼‰ï¼Œç”¨æ¥è®°å½•å·²è¿‘æ‰¾å‡ºæ¥çš„ç›®æ ‡å—å·$/;"	m	struct:gc_operation
block	initialize.h	/^    unsigned int block;$/;"	m	struct:direct_erase
block	initialize.h	/^    unsigned int block;$/;"	m	struct:local
block_num_plane	initialize.h	/^    unsigned int block_num_plane;       \/\/indicate how many blocks in a plane$/;"	m	struct:chip_info
block_plane	initialize.h	/^    unsigned int block_plane;$/;"	m	struct:parameter_value
buf_node	initialize.h	/^} buf_node;$/;"	t	typeref:struct:buffer_group
buffer	initialize.h	/^    struct buffer_info *buffer;$/;"	m	struct:dram_info	typeref:struct:dram_info::buffer_info
buffer_group	initialize.h	/^typedef struct buffer_group {$/;"	s
buffer_head	avlTree.h	/^    struct buffer_group *buffer_head;            \/*as LRU head which is most recently used*\/$/;"	m	struct:buffer_info	typeref:struct:buffer_info::buffer_group
buffer_info	avlTree.h	/^typedef struct buffer_info {$/;"	s
buffer_management	initialize.h	/^    int buffer_management;          \/\/indicates that there are buffer management or not$/;"	m	struct:parameter_value
buffer_management	ssd.c	/^struct ssd_info *buffer_management(struct ssd_info *ssd) {$/;"	f
buffer_sector_count	avlTree.h	/^    unsigned int buffer_sector_count;$/;"	m	struct:buffer_info
buffer_tail	avlTree.h	/^    struct buffer_group *buffer_tail;            \/*as LRU tail which is least recently used*\/$/;"	m	struct:buffer_info	typeref:struct:buffer_info::buffer_group
c	Session.vim	/^nnoremap <buffer> c :exec "cd ".b:completePathEsc$/;"	m
calc_req_slack_time	ssd.c	/^int calc_req_slack_time(struct request * req)$/;"	f
can_erase_block	initialize.h	/^    int can_erase_block;                \/\/è®°å½•åœ¨ä¸€ä¸ªplaneä¸­å‡†å¤‡åœ¨gcæ“ä½œä¸­è¢«æ“¦é™¤æ“ä½œçš„å—,-1è¡¨ç¤ºè¿˜æ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„å—$/;"	m	struct:plane_info
channel	initialize.h	/^    unsigned int channel;$/;"	m	struct:local
channel_head	initialize.h	/^    struct channel_info *channel_head;   \/\/æŒ‡å‘channelç»“æ„ä½“æ•°ç»„çš„é¦–åœ°å€$/;"	m	struct:ssd_info	typeref:struct:ssd_info::channel_info
channel_info	initialize.h	/^struct channel_info {$/;"	s
channel_number	initialize.h	/^    unsigned int channel_number;    \/\/è®°å½•SSDä¸­æœ‰å¤šå°‘ä¸ªé€šé“ï¼Œæ¯ä¸ªé€šé“æ˜¯å•ç‹¬çš„bus$/;"	m	struct:parameter_value
chip	initialize.h	/^    int chip;                            \/\/è¡¨ç¤ºåœ¨è¯¥æ€»çº¿ä¸Šæœ‰å¤šå°‘é¢—ç²’$/;"	m	struct:channel_info
chip	initialize.h	/^    unsigned int chip;$/;"	m	struct:gc_operation
chip	initialize.h	/^    unsigned int chip;$/;"	m	struct:local
chip	initialize.h	107;"	d
chip_channel	initialize.h	/^    unsigned int chip_channel[100]; \/\/è®¾ç½®SSDä¸­channelæ•°å’Œæ¯channelä¸Šé¢—ç²’çš„æ•°é‡$/;"	m	struct:parameter_value
chip_head	initialize.h	/^    struct chip_info *chip_head;$/;"	m	struct:channel_info	typeref:struct:channel_info::chip_info
chip_info	initialize.h	/^struct chip_info {$/;"	s
chip_next_predict_time_diff	initialize.h	/^        int chip_next_predict_time_diff;\/\/ recording the next predict time diff for restoring.$/;"	m	struct:gc_operation
chip_next_status	initialize.h	/^        unsigned int chip_next_status;$/;"	m	struct:gc_operation
chip_num	initialize.h	/^    unsigned int chip_num;          \/\/è®°å½•ä¸€ä¸ªSSDä¸­æœ‰å¤šå°‘ä¸ªé¢—ç²’$/;"	m	struct:parameter_value
chip_read_queue_length	initialize.h	/^int chip_read_queue_length;$/;"	m	struct:chip_info
chip_status	initialize.h	/^        unsigned int chip_status;$/;"	m	struct:gc_operation
chip_status	initialize.h	/^int chip_status;$/;"	m	struct:chip_info
chip_status_time	initialize.h	/^int chip_status_time;$/;"	m	struct:chip_info
chip_write_queue_length	initialize.h	/^int chip_write_queue_length;$/;"	m	struct:chip_info
clean_in_background	initialize.h	/^    int clean_in_background;        \/\/æ¸…é™¤æ“ä½œæ˜¯å¦åœ¨å‰å°å®Œæˆ$/;"	m	struct:parameter_value
clock_time	initialize.h	/^    int clock_time;$/;"	m	struct:dram_parameter
clock_time	initialize.h	/^    int64_t clock_time;                 \/\/è¡¨ç¤ºä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸçš„æ—¶é—´$/;"	m	struct:controller_info
complete_lsn_count	initialize.h	/^    unsigned int complete_lsn_count;   \/\/record the count of lsn served by buffer$/;"	m	struct:request
complete_time	initialize.h	/^    int64_t complete_time;            \/\/è®°å½•è¯¥å­è¯·æ±‚çš„å¤„ç†æ—¶é—´,æ—¢çœŸæ­£å†™å…¥æˆ–è€…è¯»å‡ºæ•°æ®çš„æ—¶é—´$/;"	m	struct:sub_request
compute_serve_time	flash.c	/^struct ssd_info *compute_serve_time(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die,$/;"	f
controller_info	initialize.h	/^struct controller_info {$/;"	s
copy_back	flash.c	/^copy_back(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, struct sub_request *sub) {$/;"	f
copy_back_count	initialize.h	/^    int copy_back_count;$/;"	m	struct:gc_info
copy_back_count	initialize.h	/^    unsigned long copy_back_count;$/;"	m	struct:ssd_info
copy_page_number	initialize.h	/^	unsigned int copy_page_number;$/;"	m	struct:gc_operation
copy_valid_number	initialize.h	/^	unsigned int copy_valid_number;$/;"	m	struct:gc_operation
count	avlTree.h	/^    unsigned int count;                         \/*AVLæ ‘é‡Œçš„èŠ‚ç‚¹æ€»æ•°*\/$/;"	m	struct:buffer_info
cpu_sdram	initialize.h	/^    unsigned int cpu_sdram;         \/\/è®°å½•ç‰‡å†…æœ‰å¤šå°‘$/;"	m	struct:parameter_value
creat_sub_request	flash.c	/^creat_sub_request(struct ssd_info *ssd, unsigned int lpn, int size, unsigned int state, struct request *req,$/;"	f
current_state	initialize.h	/^    int current_state;                   \/\/channel has serveral states, including idle, command\/address transfer,data transfer,unknown$/;"	m	struct:channel_info
current_state	initialize.h	/^    int current_state;                  \/\/channel has serveral states, including idle, command\/address transfer,data transfer,unknown$/;"	m	struct:chip_info
current_state	initialize.h	/^    unsigned int current_state;        \/\/è¡¨ç¤ºè¯¥å­è¯·æ±‚æ‰€å¤„çš„çŠ¶æ€ï¼Œè§å®å®šä¹‰sub request$/;"	m	struct:sub_request
current_time	initialize.h	/^    int64_t current_time;                \/\/è®°å½•ç³»ç»Ÿæ—¶é—´$/;"	m	struct:ssd_info
current_time	initialize.h	/^    int64_t current_time;                \/\/è®°å½•è¯¥é€šé“çš„å½“å‰æ—¶é—´$/;"	m	struct:channel_info
current_time	initialize.h	/^    int64_t current_time;               \/\/è®°å½•è¯¥é€šé“çš„å½“å‰æ—¶é—´$/;"	m	struct:chip_info
current_time	initialize.h	/^    int64_t current_time;$/;"	m	struct:dram_info
current_time	initialize.h	/^    int64_t current_time;$/;"	m	struct:sub_request
debug_sign	initialize.h	/^unsigned int debug_sign;\/\/ 0 means no debug, 1 means debug.$/;"	m	struct:ssd_info
decide_gc_invoke	pagemap.c	/^int decide_gc_invoke(struct ssd_info *ssd, unsigned int channel) {$/;"	f
delete_from_channel	flash.c	/^struct ssd_info *delete_from_channel(struct ssd_info *ssd, unsigned int channel, struct sub_request *sub_req) {$/;"	f
delete_gc_node	pagemap.c	/^int delete_gc_node(struct ssd_info *ssd, unsigned int channel, struct gc_operation *gc_node) {$/;"	f
delete_w_sub_request	flash.c	/^int delete_w_sub_request(struct ssd_info *ssd, unsigned int channel, struct sub_request *sub) {$/;"	f
die	initialize.h	/^    unsigned int die;$/;"	m	struct:gc_operation
die	initialize.h	/^    unsigned int die;$/;"	m	struct:local
die	initialize.h	108;"	d
die_chip	initialize.h	/^    unsigned int die_chip;$/;"	m	struct:parameter_value
die_head	initialize.h	/^    struct die_info *die_head;$/;"	m	struct:chip_info	typeref:struct:chip_info::die_info
die_info	initialize.h	/^struct die_info {$/;"	s
die_num	initialize.h	/^    unsigned int die_num;               \/\/è¡¨ç¤ºä¸€ä¸ªé¢—ç²’ä¸­æœ‰å¤šå°‘ä¸ªdie$/;"	m	struct:chip_info
direct_erase	initialize.h	/^struct direct_erase {$/;"	s
direct_erase_count	initialize.h	/^    unsigned long direct_erase_count;$/;"	m	struct:ssd_info
dirty_clean	initialize.h	/^    unsigned int dirty_clean;           \/\/it is flag of the data has been modified, one bit indicates one subpage. EX. 0001 indicates the first subpage is dirty$/;"	m	struct:buffer_group
distri_flag	initialize.h	/^    int distri_flag;                   \/\/ indicate whether this request has been distributed already$/;"	m	struct:request
distribute	ssd.c	/^struct ssd_info *distribute(struct ssd_info *ssd) {$/;"	f
dram	initialize.h	/^    struct dram_info *dram;$/;"	m	struct:ssd_info	typeref:struct:ssd_info::dram_info
dram_active_current	initialize.h	/^    double dram_active_current;     \/\/cpu sdram work current   uA$/;"	m	struct:parameter_value
dram_capacity	initialize.h	/^    unsigned int dram_capacity;     \/\/è®°å½•SSDä¸­DRAM capacity$/;"	m	struct:parameter_value
dram_capacity	initialize.h	/^    unsigned int dram_capacity;$/;"	m	struct:dram_info
dram_info	initialize.h	/^struct dram_info {$/;"	s
dram_parameter	initialize.h	/^struct dram_parameter {$/;"	s
dram_paramters	initialize.h	/^    struct dram_parameter *dram_paramters;$/;"	m	struct:dram_info	typeref:struct:dram_info::dram_parameter
dram_refresh_current	initialize.h	/^    double dram_refresh_current;    \/\/cpu sdram work current   uA$/;"	m	struct:parameter_value
dram_standby_current	initialize.h	/^    double dram_standby_current;    \/\/cpu sdram work current   uA$/;"	m	struct:parameter_value
dram_voltage	initialize.h	/^    double dram_voltage;            \/\/cpu sdram work voltage  V$/;"	m	struct:parameter_value
dynamic_advanced_process	flash.c	/^struct ssd_info *dynamic_advanced_process(struct ssd_info *ssd, unsigned int channel, unsigned int chip) {$/;"	f
dynamic_allocation	initialize.h	/^    int dynamic_allocation;         \/\/è®°å½•åŠ¨æ€åˆ†é…çš„æ–¹å¼$/;"	m	struct:parameter_value
energy_consumption	initialize.h	/^    double energy_consumption;         \/\/è®°å½•è¯¥è¯·æ±‚çš„èƒ½é‡æ¶ˆè€—ï¼Œå•ä½ä¸ºuJ$/;"	m	struct:request
energy_consumption	initialize.h	/^    double energy_consumption;     \/\/è¯¥planeèŠ±äº†å¤šå°‘èƒ½é‡åœ¨gcæ“ä½œä¸Š$/;"	m	struct:gc_info
entry	initialize.h	/^struct entry {$/;"	s
erase	initialize.h	/^        unsigned int erase;\/\/ erase 1 :erase. 2: verify$/;"	m	struct:gc_operation
erase_count	initialize.h	/^    int erase_count;$/;"	m	struct:gc_info
erase_count	initialize.h	/^    unsigned int erase_count;          \/\/å—çš„æ“¦é™¤æ¬¡æ•°ï¼Œè¯¥é¡¹è®°å½•åœ¨ramä¸­ï¼Œç”¨äºGC$/;"	m	struct:blk_info
erase_count	initialize.h	/^    unsigned long erase_count;$/;"	m	struct:channel_info
erase_count	initialize.h	/^    unsigned long erase_count;$/;"	m	struct:chip_info
erase_count	initialize.h	/^    unsigned long erase_count;$/;"	m	struct:ssd_info
erase_node	initialize.h	/^    struct direct_erase *erase_node;    \/\/ç”¨æ¥è®°å½•å¯ä»¥ç›´æ¥åˆ é™¤çš„å—å·,åœ¨è·å–æ–°çš„ppnæ—¶ï¼Œæ¯å½“å‡ºç°invalid_page_num==64æ—¶ï¼Œå°†å…¶æ·»åŠ åˆ°è¿™ä¸ªæŒ‡é’ˆä¸Šï¼Œä¾›GCæ“ä½œæ—¶ç›´æ¥åˆ é™¤$/;"	m	struct:plane_info	typeref:struct:plane_info::direct_erase
erase_operation	pagemap.c	/^erase_operation(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane,$/;"	f
erase_planes	pagemap.c	/^erase_planes(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die1, unsigned int plane1,$/;"	f
ers_invalid	initialize.h	/^    unsigned int ers_invalid;           \/\/è®°å½•è¯¥planeä¸­æ“¦é™¤å¤±æ•ˆçš„å—æ•°$/;"	m	struct:plane_info
ers_limit	initialize.h	/^    unsigned int ers_limit;             \/\/è¯¥chipä¸­æ¯å—èƒ½å¤Ÿè¢«æ“¦é™¤çš„æ¬¡æ•°$/;"	m	struct:chip_info
ers_limit	initialize.h	/^    unsigned int ers_limit;         \/\/è®°å½•æ¯ä¸ªå—å¯æ“¦é™¤çš„æ¬¡æ•°$/;"	m	struct:parameter_value
event	initialize.h	/^    struct event_node *event;            \/\/äº‹ä»¶é˜Ÿåˆ—ï¼Œæ¯äº§ç”Ÿä¸€ä¸ªæ–°çš„äº‹ä»¶ï¼ŒæŒ‰ç…§æ—¶é—´é¡ºåºåŠ åˆ°è¿™ä¸ªé˜Ÿåˆ—ï¼Œåœ¨simulateå‡½æ•°æœ€åï¼Œæ ¹æ®è¿™ä¸ªé˜Ÿåˆ—é˜Ÿé¦–çš„æ—¶é—´ï¼Œç¡®å®šæ—¶é—´$/;"	m	struct:ssd_info	typeref:struct:ssd_info::event_node
event	initialize.h	/^    struct event_node *event;$/;"	m	struct:channel_info	typeref:struct:channel_info::event_node
event_node	initialize.h	/^struct event_node {$/;"	s
file_assert	pagemap.c	/^void file_assert(int error, char *s) {$/;"	f
find_active_block	flash.c	/^find_active_block(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane) {$/;"	f
find_interleave_twoplane_page	flash.c	/^find_interleave_twoplane_page(struct ssd_info *ssd, struct sub_request *one_page, unsigned int command) {$/;"	f
find_interleave_twoplane_sub_request	flash.c	/^find_interleave_twoplane_sub_request(struct ssd_info *ssd, unsigned int channel, struct sub_request *sub_request_one,$/;"	f
find_level_page	flash.c	/^Status find_level_page(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die,$/;"	f
find_location	pagemap.c	/^struct local *find_location(struct ssd_info *ssd, unsigned int ppn) {$/;"	f
find_nearest_event	ssd.c	/^int64_t find_nearest_event(struct ssd_info *ssd) {$/;"	f
find_ppn	pagemap.c	/^find_ppn(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane,$/;"	f
find_read_sub_request	flash.c	/^find_read_sub_request(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die) {$/;"	f
find_write_sub_request	flash.c	/^struct sub_request *find_write_sub_request(struct ssd_info *ssd, unsigned int channel) {$/;"	f
flag	initialize.h	/^    int flag;                            \/\/indicates if this node is the last 20% of the LRU list$/;"	m	struct:buffer_group
flag	initialize.h	/^    int flag;$/;"	m	struct:ssd_info
flash_page_state_modify	flash.c	/^flash_page_state_modify(struct ssd_info *ssd, struct sub_request *sub, unsigned int channel, unsigned int chip,$/;"	f
free	avlTree.h	/^    int (*free)(TREE_NODE *);$/;"	m	struct:buffer_info
freeFunc	initialize.c	/^extern int freeFunc(TREE_NODE *pNode) {$/;"	f
free_all_node	ssd.c	/^void free_all_node(struct ssd_info *ssd) {$/;"	f
free_page	initialize.h	/^    unsigned int free_page;             \/\/è¯¥planeä¸­æœ‰å¤šå°‘free page$/;"	m	struct:plane_info
free_page_num	initialize.h	/^    unsigned int free_page_num;        \/\/è®°å½•è¯¥å—ä¸­çš„freeé¡µä¸ªæ•°ï¼ŒåŒä¸Š$/;"	m	struct:blk_info
free_state	initialize.h	/^    int free_state;                    \/\/each bit indicates the subpage is free or occupted. 1 indicates that the bit is free and 0 indicates that the bit is used$/;"	m	struct:page_info
frequency	initialize.h	/^    unsigned int frequency;             \/\/è¡¨ç¤ºè¯¥æ§åˆ¶å™¨çš„å·¥ä½œé¢‘ç‡$/;"	m	struct:controller_info
gc	initialize.h	/^    int gc;                         \/\/è®°å½•gcç­–ç•¥$/;"	m	struct:parameter_value
gc	pagemap.c	/^unsigned int gc(struct ssd_info *ssd, unsigned int channel, unsigned int flag) {$/;"	f
gc_command	initialize.h	/^    struct gc_operation *gc_command;     \/\/è®°å½•éœ€è¦äº§ç”Ÿgcçš„ä½ç½®$/;"	m	struct:channel_info	typeref:struct:channel_info::gc_operation
gc_copy_back	initialize.h	/^    unsigned long gc_copy_back;$/;"	m	struct:ssd_info
gc_direct_erase	pagemap.c	/^gc_direct_erase(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane) {$/;"	f
gc_for_channel	pagemap.c	/^Status gc_for_channel(struct ssd_info *ssd, unsigned int channel) {$/;"	f
gc_hard_threshold	initialize.h	/^    float gc_hard_threshold;        \/\/æ™®é€šç­–ç•¥ä¸­ç”¨ä¸åˆ°è¯¥å‚æ•°ï¼Œåªæœ‰åœ¨ä¸»åŠ¨å†™ç­–ç•¥ä¸­ï¼Œå½“æ»¡è¶³è¿™ä¸ªé˜ˆå€¼æ—¶ï¼ŒGCæ“ä½œä¸å¯ä¸­æ–­$/;"	m	struct:parameter_value
gc_info	initialize.h	/^struct gc_info {$/;"	s
gc_operation	initialize.h	/^struct gc_operation {$/;"	s
gc_read_inner	initialize.h	/^        unsigned int gc_read_inner;$/;"	m	struct:gc_operation
gc_request	initialize.h	/^    unsigned int gc_request;             \/\/è®°å½•åœ¨SSDä¸­ï¼Œå½“å‰æ—¶åˆ»æœ‰å¤šå°‘gcæ“ä½œçš„è¯·æ±‚$/;"	m	struct:ssd_info
gc_suspend_doing	initialize.h	/^unsigned int gc_suspend_doing;$/;"	m	struct:ssd_info
gc_suspend_times	initialize.h	/^unsigned int gc_suspend_times;\/\/ statistic for gc suspend times.$/;"	m	struct:ssd_info
gc_threshold	initialize.h	/^    float gc_threshold;             \/\/å½“è¾¾åˆ°è¿™ä¸ªé˜ˆå€¼æ—¶ï¼Œå¼€å§‹GCæ“ä½œï¼Œåœ¨ä¸»åŠ¨å†™ç­–ç•¥ä¸­ï¼Œå¼€å§‹GCæ“ä½œåå¯ä»¥ä¸´æ—¶ä¸­æ–­GCæ“ä½œï¼ŒæœåŠ¡æ–°åˆ°çš„è¯·æ±‚ï¼›åœ¨æ™®é€šç­–ç•¥ä¸­ï¼ŒGCä¸å¯ä¸­æ–­$/;"	m	struct:parameter_value
gc_try_to_suspend_function	flash.c	/^int gc_try_to_suspend_function(struct ssd_info *ssd,  struct gc_operation *gc_node, unsigned int channel, unsigned int chip, unsigned int current_state, unsigned int next_state, int time)$/;"	f
gc_write_inner	initialize.h	/^        unsigned int gc_write_inner;$/;"	m	struct:gc_operation
get_ppn	pagemap.c	/^get_ppn(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane,$/;"	f
get_ppn_for_advanced_commands	flash.c	/^get_ppn_for_advanced_commands(struct ssd_info *ssd, unsigned int channel, unsigned int chip, struct sub_request **subs,$/;"	f
get_ppn_for_gc	pagemap.c	/^get_ppn_for_gc(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane) {$/;"	f
get_ppn_for_normal_command	flash.c	/^get_ppn_for_normal_command(struct ssd_info *ssd, unsigned int channel, unsigned int chip, struct sub_request *sub) {$/;"	f
get_ppn_for_pre_process	pagemap.c	/^unsigned int get_ppn_for_pre_process(struct ssd_info *ssd, unsigned int lsn) {$/;"	f
get_requests	ssd.c	/^int get_requests(struct ssd_info *ssd) {$/;"	f
go_one_step	flash.c	/^Status go_one_step(struct ssd_info *ssd, struct sub_request *sub1, struct sub_request *sub2, unsigned int aim_state,$/;"	f
greed_CB_ad	initialize.h	/^    int greed_CB_ad;                \/\/0 don't use copyback advanced commands greedily; 1 use copyback advanced commands greedily$/;"	m	struct:parameter_value
greed_MPW_ad	initialize.h	/^    int greed_MPW_ad;               \/\/0 don't use multi-plane write advanced commands greedily; 1 use multi-plane write advanced commands greedily$/;"	m	struct:parameter_value
group	initialize.h	/^    unsigned int group;                 \/\/the first data logic sector number of a group stored in buffer$/;"	m	struct:buffer_group
gx	Session.vim	/^nmap gx <Plug>NetrwBrowseX$/;"	m
gx	Session.vim	/^vmap gx <Plug>NetrwBrowseXVis$/;"	m
initialize_block	initialize.c	/^struct blk_info *initialize_block(struct blk_info *p_block, struct parameter_value *parameter) {$/;"	f
initialize_channels	initialize.c	/^struct ssd_info *initialize_channels(struct ssd_info *ssd) {$/;"	f
initialize_chip	initialize.c	/^struct chip_info *initialize_chip(struct chip_info *p_chip, struct parameter_value *parameter, long long current_time) {$/;"	f
initialize_die	initialize.c	/^struct die_info *initialize_die(struct die_info *p_die, struct parameter_value *parameter, long long current_time) {$/;"	f
initialize_dram	initialize.c	/^struct dram_info *initialize_dram(struct ssd_info *ssd) {$/;"	f
initialize_page	initialize.c	/^struct page_info *initialize_page(struct page_info *p_page) {$/;"	f
initialize_plane	initialize.c	/^struct plane_info *initialize_plane(struct plane_info *p_plane, struct parameter_value *parameter) {$/;"	f
initiation	initialize.c	/^struct ssd_info *initiation(struct ssd_info *ssd) {$/;"	f
insert2buffer	flash.c	/^insert2buffer(struct ssd_info *ssd, unsigned int lpn, int state, struct sub_request *sub, struct request *req) {$/;"	f
inter_mplane_count	initialize.h	/^    unsigned long inter_mplane_count;$/;"	m	struct:ssd_info
inter_mplane_prog_count	initialize.h	/^    unsigned long inter_mplane_prog_count;$/;"	m	struct:ssd_info
interleave_count	initialize.h	/^    unsigned long interleave_count;$/;"	m	struct:ssd_info
interleave_erase_count	initialize.h	/^    unsigned long interleave_erase_count;$/;"	m	struct:ssd_info
interleave_mplane_erase_count	initialize.h	/^    unsigned long interleave_mplane_erase_count;$/;"	m	struct:ssd_info
interleave_read_count	initialize.h	/^    unsigned long interleave_read_count;$/;"	m	struct:ssd_info
interleaving	initialize.h	/^    int interleaving;$/;"	m	struct:parameter_value
interrupt_gc	pagemap.c	/^int interrupt_gc(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane,$/;"	f
invalid_page_num	initialize.h	/^    unsigned int invalid_page_num;     \/\/è®°å½•è¯¥å—ä¸­å¤±æ•ˆé¡µçš„ä¸ªæ•°ï¼ŒåŒä¸Š$/;"	m	struct:blk_info
j	Session.vim	/^nnoremap <buffer> j gj$/;"	m
judging_read_in_gc_chip	ssd.c	/^int judging_read_in_gc_chip(struct ssd_info *ssd, int channel)$/;"	f
k	Session.vim	/^nnoremap <buffer> k gk$/;"	m
keyCompare	avlTree.h	/^    int (*keyCompare)(TREE_NODE *, TREE_NODE *);$/;"	m	struct:buffer_info
keyCompareFunc	initialize.c	/^extern int keyCompareFunc(TREE_NODE *p, TREE_NODE *p1) {$/;"	f
last_page_in_victim_deal	initialize.h	/^        unsigned int last_page_in_victim_deal;    $/;"	m	struct:gc_operation
last_sign	initialize.h	/^   int last_sign;$/;"	m	struct:sub_request
last_total_available_pages_number	initialize.h	/^int last_total_available_pages_number;$/;"	m	struct:ssd_info
last_write_page	initialize.h	/^    int last_write_page;               \/\/è®°å½•æœ€è¿‘ä¸€æ¬¡å†™æ“ä½œæ‰§è¡Œçš„é¡µæ•°,-1è¡¨ç¤ºè¯¥å—æ²¡æœ‰ä¸€é¡µè¢«å†™è¿‡$/;"	m	struct:blk_info
left_child	avlTree.h	/^    struct _AVL_TREE_NODE *left_child;$/;"	m	struct:_AVL_TREE_NODE	typeref:struct:_AVL_TREE_NODE::_AVL_TREE_NODE
load_parameters	initialize.c	/^struct parameter_value *load_parameters(char parameter_file[30]) {$/;"	f
local	initialize.h	/^struct local {$/;"	s
location	initialize.h	/^    struct local *location;           \/\/åœ¨é™æ€åˆ†é…å’Œæ··åˆåˆ†é…æ–¹å¼ä¸­ï¼Œå·²çŸ¥lpnå°±çŸ¥é“è¯¥lpnè¯¥åˆ†é…åˆ°é‚£ä¸ªchannelï¼Œchipï¼Œdieï¼Œplaneï¼Œè¿™ä¸ªç»“æ„ä½“ç”¨æ¥ä¿å­˜è®¡ç®—å¾—åˆ°çš„åœ°å€$/;"	m	struct:sub_request	typeref:struct:sub_request::local
lpn	initialize.h	/^    unsigned int lpn;                  \/\/è¿™é‡Œè¡¨ç¤ºè¯¥å­è¯·æ±‚çš„é€»è¾‘é¡µå·$/;"	m	struct:sub_request
lpn	initialize.h	/^    unsigned int lpn;$/;"	m	struct:page_info
lpn2ppn	ssd.c	/^unsigned int lpn2ppn(struct ssd_info *ssd, unsigned int lsn) {$/;"	f
lsn	initialize.h	/^    unsigned int lsn;                  \/\/è¯·æ±‚çš„èµ·å§‹åœ°å€ï¼Œé€»è¾‘åœ°å€$/;"	m	struct:request
m_plane_prog_count	initialize.h	/^    unsigned long m_plane_prog_count;$/;"	m	struct:ssd_info
m_plane_read_count	initialize.h	/^    unsigned long m_plane_read_count;$/;"	m	struct:ssd_info
main	ssd.c	/^int main() {$/;"	f
make_aged	ssd.c	/^struct ssd_info *make_aged(struct ssd_info *ssd) {$/;"	f
make_level_page	flash.c	/^Status make_level_page(struct ssd_info *ssd, struct sub_request *sub0, struct sub_request *sub1) {$/;"	f
make_same_level	flash.c	/^make_same_level(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane,$/;"	f
map	initialize.h	/^    struct map_info *map;$/;"	m	struct:dram_info	typeref:struct:dram_info::map_info
map_entry	initialize.h	/^    struct entry *map_entry;            \/\/è¯¥é¡¹æ˜¯æ˜ å°„è¡¨ç»“æ„ä½“æŒ‡é’ˆ,each entry indicate a mapping information$/;"	m	struct:map_info	typeref:struct:map_info::entry
map_info	initialize.h	/^struct map_info {$/;"	s
max_buffer_sector	avlTree.h	/^    unsigned int max_buffer_sector;$/;"	m	struct:buffer_info
max_lsn	initialize.h	/^    unsigned int max_lsn;$/;"	m	struct:ssd_info
min_lsn	initialize.h	/^    unsigned int min_lsn;$/;"	m	struct:ssd_info
move_page	pagemap.c	/^Status move_page(struct ssd_info *ssd, struct local *location, unsigned int *transfer_size) {$/;"	f
mplane_erase_conut	initialize.h	/^    unsigned long mplane_erase_conut;$/;"	m	struct:ssd_info
need_distr_flag	initialize.h	/^    unsigned int *need_distr_flag;$/;"	m	struct:request
new_services_2_write	flash.c	/^int  new_services_2_write(struct ssd_info *ssd, unsigned int channel, unsigned int *channel_busy_flag,$/;"	f
next	avlTree.h	/^    struct _AVL_TREE_NODE *next;$/;"	m	struct:_AVL_TREE_NODE	typeref:struct:_AVL_TREE_NODE::_AVL_TREE_NODE
next_node	initialize.h	/^    struct direct_erase *next_node;$/;"	m	struct:direct_erase	typeref:struct:direct_erase::direct_erase
next_node	initialize.h	/^    struct event_node *next_node;$/;"	m	struct:event_node	typeref:struct:event_node::event_node
next_node	initialize.h	/^    struct gc_operation *next_node;$/;"	m	struct:gc_operation	typeref:struct:gc_operation::gc_operation
next_node	initialize.h	/^    struct request *next_node;         \/\/æŒ‡å‘ä¸‹ä¸€ä¸ªè¯·æ±‚ç»“æ„ä½“$/;"	m	struct:request	typeref:struct:request::request
next_node	initialize.h	/^    struct sub_request *next_node;    \/\/æŒ‡å‘åŒä¸€ä¸ªchannelä¸­ä¸‹ä¸€ä¸ªå­è¯·æ±‚ç»“æ„ä½“$/;"	m	struct:sub_request	typeref:struct:sub_request::sub_request
next_request_time	initialize.h	/^    int64_t next_request_time;$/;"	m	struct:ssd_info
next_state	initialize.h	/^    int next_state;$/;"	m	struct:channel_info
next_state	initialize.h	/^    int next_state;$/;"	m	struct:chip_info
next_state	initialize.h	/^    unsigned int next_state;$/;"	m	struct:sub_request
next_state_predict_time	initialize.h	/^    int64_t next_state_predict_time;     \/\/the predict time of next state, used to decide the sate at the moment$/;"	m	struct:channel_info
next_state_predict_time	initialize.h	/^    int64_t next_state_predict_time;    \/\/the predict time of next state, used to decide the sate at the moment$/;"	m	struct:chip_info
next_state_predict_time	initialize.h	/^    int64_t next_state_predict_time;$/;"	m	struct:sub_request
next_subs	initialize.h	/^    struct sub_request *next_subs;    \/\/æŒ‡å‘å±äºåŒä¸€ä¸ªrequestçš„å­è¯·æ±‚$/;"	m	struct:sub_request	typeref:struct:sub_request::sub_request
no_buffer_distribute	ssd.c	/^struct ssd_info *no_buffer_distribute(struct ssd_info *ssd) {$/;"	f
node	initialize.h	/^    TREE_NODE node;                     \/\/æ ‘èŠ‚ç‚¹çš„ç»“æ„ä¸€å®šè¦æ”¾åœ¨ç”¨æˆ·è‡ªå®šä¹‰ç»“æ„çš„æœ€å‰é¢ï¼Œæ³¨æ„!$/;"	m	struct:buffer_group
num_w_cycle	initialize.h	/^int num_w_cycle; \/\/ number of the iterarions now$/;"	m	struct:chip_info
operating_current	initialize.h	/^    double operating_current;       \/\/NAND FLASHçš„å·¥ä½œç”µæµå•ä½æ˜¯uA$/;"	m	struct:parameter_value
operation	initialize.h	/^    unsigned int operation;            \/\/è¡¨ç¤ºè¯¥å­è¯·æ±‚çš„ç±»å‹ï¼Œé™¤äº†è¯»1 å†™0ï¼Œè¿˜æœ‰æ“¦é™¤ï¼Œtwo planeç­‰æ“ä½œ$/;"	m	struct:sub_request
operation	initialize.h	/^    unsigned int operation;            \/\/è¯·æ±‚çš„ç§ç±»ï¼Œ1ä¸ºè¯»ï¼Œ0ä¸ºå†™$/;"	m	struct:request
orderListInsert	avlTree.c	/^static int orderListInsert$/;"	f	file:
orderListRemove	avlTree.c	/^static int orderListRemove$/;"	f	file:
original_total_pages_number	initialize.h	/^int original_total_pages_number;$/;"	m	struct:ssd_info
outputfile	initialize.h	/^    FILE *outputfile;$/;"	m	struct:ssd_info
outputfilename	initialize.h	/^    char outputfilename[30];$/;"	m	struct:ssd_info
overprovide	initialize.h	/^    float overprovide;$/;"	m	struct:parameter_value
p	Session.vim	/^nnoremap <buffer> p :wincmd p$/;"	m
pListHeader	avlTree.h	/^    TREE_NODE *pListHeader;$/;"	m	struct:buffer_info
pListTail	avlTree.h	/^    TREE_NODE *pListTail;$/;"	m	struct:buffer_info
pTreeHeader	avlTree.h	/^    TREE_NODE *pTreeHeader;                     \/*for search target lsn is LRU table*\/$/;"	m	struct:buffer_info
page	initialize.h	/^    unsigned int page;            \/\/è¯¥å‚æ•°åªåœ¨å¯ä¸­æ–­çš„gcå‡½æ•°ä¸­ä½¿ç”¨ï¼ˆgc_interruptï¼‰ï¼Œç”¨æ¥è®°å½•å·²ç»å®Œæˆçš„æ•°æ®è¿ç§»çš„é¡µå·$/;"	m	struct:gc_operation
page	initialize.h	/^    unsigned int page;$/;"	m	struct:local
page	initialize.h	/^    unsigned int page;$/;"	m	struct:ssd_info
page_block	initialize.h	/^    unsigned int page_block;$/;"	m	struct:parameter_value
page_capacity	initialize.h	/^    unsigned int page_capacity;$/;"	m	struct:parameter_value
page_head	initialize.h	/^    struct page_info *page_head;       \/\/è®°å½•æ¯ä¸€å­é¡µçš„çŠ¶æ€$/;"	m	struct:blk_info	typeref:struct:blk_info::page_info
page_info	initialize.h	/^struct page_info {                      \/\/lpnè®°å½•è¯¥ç‰©ç†é¡µå­˜å‚¨çš„é€»è¾‘é¡µï¼Œå½“è¯¥é€»è¾‘é¡µæœ‰æ•ˆæ—¶ï¼Œvalid_stateå¤§äº0ï¼Œfree_stateå¤§äº0ï¼›$/;"	s
page_num_block	initialize.h	/^    unsigned int page_num_block;        \/\/indicate how many pages in a block$/;"	m	struct:chip_info
parameter	initialize.h	/^    struct parameter_value *parameter;   \/\/SSDå‚æ•°å› å­$/;"	m	struct:ssd_info	typeref:struct:ssd_info::parameter_value
parameter_value	initialize.h	/^struct parameter_value {$/;"	s
parameterfilename	initialize.h	/^    char parameterfilename[30];$/;"	m	struct:ssd_info
pipelining	initialize.h	/^    int pipelining;$/;"	m	struct:parameter_value
plane	initialize.h	/^    unsigned int plane;$/;"	m	struct:gc_operation
plane	initialize.h	/^    unsigned int plane;$/;"	m	struct:local
plane_die	initialize.h	/^    unsigned int plane_die;$/;"	m	struct:parameter_value
plane_head	initialize.h	/^    struct plane_info *plane_head;$/;"	m	struct:die_info	typeref:struct:die_info::plane_info
plane_info	initialize.h	/^struct plane_info {$/;"	s
plane_num_die	initialize.h	/^    unsigned int plane_num_die;         \/\/indicate how many planes in a die$/;"	m	struct:chip_info
pn	initialize.h	/^    unsigned int pn;                \/\/ç‰©ç†å·ï¼Œæ—¢å¯ä»¥è¡¨ç¤ºç‰©ç†é¡µå·ï¼Œä¹Ÿå¯ä»¥è¡¨ç¤ºç‰©ç†å­é¡µå·ï¼Œä¹Ÿå¯ä»¥è¡¨ç¤ºç‰©ç†å—å·$/;"	m	struct:entry
pos_in_copy	initialize.h	/^	unsigned int pos_in_copy;$/;"	m	struct:gc_operation
power	initialize.h	/^    float power;                        \/\/è¡¨ç¤ºæ§åˆ¶å™¨å•ä½æ—¶é—´çš„èƒ½è€—$/;"	m	struct:controller_info
ppn	initialize.h	/^    unsigned int ppn;                  \/\/åˆ†é…é‚£ä¸ªç‰©ç†å­é¡µç»™è¿™ä¸ªå­è¯·æ±‚ã€‚åœ¨multi_chip_page_mappingä¸­ï¼Œäº§ç”Ÿå­é¡µè¯·æ±‚æ—¶å¯èƒ½å°±çŸ¥é“psnçš„å€¼ï¼Œå…¶ä»–æ—¶å€™psnçš„å€¼ç”±page_map_read,page_map_writeç­‰FTLæœ€åº•å±‚å‡½æ•°äº§ç”Ÿã€‚$/;"	m	struct:sub_request
pre_node	initialize.h	/^    struct event_node *pre_node;$/;"	m	struct:event_node	typeref:struct:event_node::event_node
pre_process_page	pagemap.c	/^struct ssd_info *pre_process_page(struct ssd_info *ssd) {$/;"	f
predict_time	initialize.h	/^    int64_t predict_time;            \/\/è®°å½•è¿™ä¸ªæ—¶é—´å¼€å§‹çš„é¢„è®¡æ—¶é—´ï¼Œé˜²æ­¢æå‰æ‰§è¡Œè¿™ä¸ªæ—¶é—´$/;"	m	struct:event_node
prev	avlTree.h	/^    struct _AVL_TREE_NODE *prev;$/;"	m	struct:_AVL_TREE_NODE	typeref:struct:_AVL_TREE_NODE::_AVL_TREE_NODE
printf_every_chip_read_subrequest	ssd.c	/^int printf_every_chip_read_subrequest(struct ssd_info *ssd)$/;"	f
printf_every_chip_static_subrequest	ssd.c	/^int printf_every_chip_static_subrequest(struct ssd_info *ssd)$/;"	f
printf_gc_node_information	ssd.c	/^int printf_gc_node_information(struct gc_operation* gc_node)$/;"	f
printf_ssd_gc_node	ssd.c	/^void printf_ssd_gc_node(struct ssd_info *ssd)$/;"	f
printf_ssd_request_queue	ssd.c	/^void printf_ssd_request_queue(struct ssd_info *ssd)$/;"	f
printfsub_request_status	ssd.c	/^void printfsub_request_status(struct ssd_info *ssd)$/;"	f
priority	initialize.h	/^    unsigned int priority;        \/\/è®°å½•è¯¥gcæ“ä½œçš„ä¼˜å…ˆçº§ï¼Œ1è¡¨ç¤ºä¸å¯ä¸­æ–­ï¼Œ0è¡¨ç¤ºå¯ä¸­æ–­ï¼ˆè½¯é˜ˆå€¼äº§ç”Ÿçš„gcè¯·æ±‚ï¼‰$/;"	m	struct:gc_operation
process	flash.c	/^struct ssd_info *process(struct ssd_info *ssd) {$/;"	f
process_time	initialize.h	/^    int64_t process_time;          \/\/è¯¥planeèŠ±äº†å¤šå°‘æ—¶é—´åœ¨gcæ“ä½œä¸Š$/;"	m	struct:gc_info
program_count	initialize.h	/^    unsigned long program_count;$/;"	m	struct:channel_info
program_count	initialize.h	/^    unsigned long program_count;$/;"	m	struct:chip_info
program_count	initialize.h	/^    unsigned long program_count;$/;"	m	struct:ssd_info
q	Session.vim	/^inoremap <buffer> <silent> q :close$/;"	m
q	Session.vim	/^nnoremap <buffer> <silent> q :close$/;"	m
queue_length	initialize.h	/^    int queue_length;               \/\/è¯·æ±‚é˜Ÿåˆ—çš„é•¿åº¦é™åˆ¶$/;"	m	struct:parameter_value
quick_radio	initialize.h	/^    float quick_radio;$/;"	m	struct:parameter_value
read	initialize.h	/^        unsigned int read;$/;"	m	struct:gc_operation
read_avg	initialize.h	/^    int64_t read_avg;                    \/\/è®°å½•ç”¨äºè®¡ç®—è¯»è¯·æ±‚å¹³å‡å“åº”æ—¶é—´çš„æ—¶é—´$/;"	m	struct:ssd_info
read_count	initialize.h	/^    unsigned long read_count;           \/\/how many read count in the process of workload$/;"	m	struct:chip_info
read_count	initialize.h	/^    unsigned long read_count;$/;"	m	struct:channel_info
read_count	initialize.h	/^    unsigned long read_count;$/;"	m	struct:ssd_info
read_hit	avlTree.h	/^    unsigned long read_hit;                      \/*è¿™é‡Œçš„hitéƒ½è¡¨ç¤ºsectorçš„å‘½ä¸­æ¬¡æ•°æˆ–æ˜¯æ²¡å‘½ä¸­çš„æ¬¡æ•°*\/$/;"	m	struct:buffer_info
read_miss_hit	avlTree.h	/^    unsigned long read_miss_hit;$/;"	m	struct:buffer_info
read_request_count	initialize.h	/^    unsigned int read_request_count;     \/\/è®°å½•è¯»æ“ä½œçš„æ¬¡æ•°$/;"	m	struct:ssd_info
read_write_end	initialize.h	/^        unsigned int read_write_end;$/;"	m	struct:gc_operation
real_time_subreq	initialize.h	/^    unsigned int real_time_subreq;       \/\/è®°å½•å®æ—¶çš„å†™è¯·æ±‚ä¸ªæ•°ï¼Œç”¨åœ¨å…¨åŠ¨æ€åˆ†é…æ—¶ï¼Œchannelä¼˜å…ˆçš„æƒ…å†µ$/;"	m	struct:ssd_info
related_mapping	initialize.h	/^    int related_mapping;$/;"	m	struct:parameter_value
reordering_req	ssd.c	/^int reordering_req(struct request * req )$/;"	f
request	initialize.h	/^struct request {$/;"	s
request_queue	initialize.h	/^    struct request *request_queue;       \/\/dynamic request queue$/;"	m	struct:ssd_info	typeref:struct:ssd_info::request
request_queue_length	initialize.h	/^    unsigned int request_queue_length;$/;"	m	struct:ssd_info
request_tail	initialize.h	/^    struct request *request_tail;         \/\/ the tail of the request queue$/;"	m	struct:ssd_info	typeref:struct:ssd_info::request
response_time	initialize.h	/^    int64_t response_time;$/;"	m	struct:request
right_child	avlTree.h	/^    struct _AVL_TREE_NODE *right_child;$/;"	m	struct:_AVL_TREE_NODE	typeref:struct:_AVL_TREE_NODE::_AVL_TREE_NODE
s:cpo_save	Session.vim	/^let s:cpo_save=&cpo$/;"	v
s:l	Session.vim	/^let s:l = 2 - ((0 * winheight(0) + 31) \/ 62)$/;"	v
s:l	Session.vim	/^let s:l = 341 - ((29 * winheight(0) + 31) \/ 62)$/;"	v
s:l	Session.vim	/^let s:l = 5 - ((2 * winheight(0) + 16) \/ 32)$/;"	v
s:so_save	Session.vim	/^let s:so_save = &so | let s:siso_save = &siso | set so=0 siso=0$/;"	v
s:sx	Session.vim	/^let s:sx = expand("<sfile>:p:r")."x.vim"$/;"	v
s:wipebuf	Session.vim	/^  let s:wipebuf = bufnr('%')$/;"	v
scheduling_algorithm	initialize.h	/^    int scheduling_algorithm;       \/\/è®°å½•ä½¿ç”¨å“ªç§è°ƒåº¦ç®—æ³•ï¼Œ1:FCFS$/;"	m	struct:parameter_value
serviced_time	initialize.h	/^   int64_t serviced_time; $/;"	m	struct:sub_request
services_2_gc_busy_in_chip	flash.c	/^int services_2_gc_busy_in_chip(struct ssd_info *ssd)$/;"	f
services_2_r_cmd_trans_and_complete	flash.c	/^int  services_2_r_cmd_trans_and_complete(struct ssd_info *ssd) {$/;"	f
services_2_r_data_trans	flash.c	/^Status services_2_r_data_trans(struct ssd_info *ssd, unsigned int channel, unsigned int *channel_busy_flag,$/;"	f
services_2_r_wait	flash.c	/^int services_2_r_wait(struct ssd_info *ssd, unsigned int channel, unsigned int *channel_busy_flag,$/;"	f
services_2_write	flash.c	/^Status services_2_write(struct ssd_info *ssd, unsigned int channel, unsigned int *channel_busy_flag,$/;"	f
services_2_write_busy_in_chip	flash.c	/^int services_2_write_busy_in_chip(struct ssd_info *ssd)$/;"	f
set_entry_state	pagemap.c	/^int set_entry_state(struct ssd_info *ssd, unsigned int lsn, unsigned int size) {$/;"	f
sign_for_preemptive	initialize.h	/^        unsigned int sign_for_preemptive;$/;"	m	struct:gc_operation
simulate	ssd.c	/^struct ssd_info *simulate(struct ssd_info *ssd) {$/;"	f
size	initialize.h	/^    int size;$/;"	m	struct:sub_request
size	initialize.h	/^    unsigned int size;                 \/\/è¯·æ±‚çš„å¤§å°ï¼Œæ—¢å¤šå°‘ä¸ªæ‰‡åŒº$/;"	m	struct:request
size	ssd.c	/^unsigned int size(unsigned int stored) {$/;"	f
slack_time	initialize.h	/^   int64_t slack_time;$/;"	m	struct:sub_request
sleep_current	initialize.h	/^    float sleep_current;$/;"	m	struct:dram_parameter
small_large_write	initialize.h	/^    unsigned int small_large_write; \/\/the threshould of large write, large write do not occupt buffer, which is written back to flash directly$/;"	m	struct:parameter_value
ssd_energy	initialize.h	/^    double ssd_energy;                   \/\/SSDçš„èƒ½è€—ï¼Œæ˜¯æ—¶é—´å’ŒèŠ¯ç‰‡æ•°çš„å‡½æ•°,èƒ½è€—å› å­$/;"	m	struct:ssd_info
ssd_info	initialize.h	/^struct ssd_info {$/;"	s
state	initialize.h	/^    int state;                      \/\/åå…­è¿›åˆ¶è¡¨ç¤ºçš„è¯æ˜¯0000-FFFFï¼Œæ¯ä½è¡¨ç¤ºç›¸åº”çš„å­é¡µæ˜¯å¦æœ‰æ•ˆï¼ˆé¡µæ˜ å°„ï¼‰ã€‚æ¯”å¦‚åœ¨è¿™ä¸ªé¡µä¸­ï¼Œ0ï¼Œ1å·å­é¡µæœ‰æ•ˆï¼Œ2ï¼Œ3æ— æ•ˆï¼Œè¿™ä¸ªåº”è¯¥æ˜¯0x0003. lxc é¡ºåºä¸ºï¼š3210é¡ºåºï¼Œä¸”æœ‰æ•ˆä¸º1ï¼Œè€Œä¸”æ­¤å¤„å¯ä»¥æœ‰è‡³å°‘32ä¸ªå­é¡µã€‚ã€‚$/;"	m	struct:entry
state	initialize.h	/^    unsigned int state;              \/\/ä½¿ç”¨stateçš„æœ€é«˜ä½è¡¨ç¤ºè¯¥å­è¯·æ±‚æ˜¯å¦æ˜¯ä¸€å¯¹å¤šæ˜ å°„å…³ç³»ä¸­çš„ä¸€ä¸ªï¼Œæ˜¯çš„è¯ï¼Œéœ€è¦è¯»åˆ°bufferä¸­ã€‚1è¡¨ç¤ºæ˜¯ä¸€å¯¹å¤šï¼Œ0è¡¨ç¤ºä¸ç”¨å†™åˆ°buffer$/;"	m	struct:sub_request
state	initialize.h	/^    unsigned int state;           \/\/è®°å½•å½“å‰gcè¯·æ±‚çš„çŠ¶æ€$/;"	m	struct:gc_operation
state	initialize.h	/^    unsigned int state;$/;"	m	struct:Dram_write_map
static_allocation	initialize.h	/^    int static_allocation;          \/\/è®°å½•æ˜¯é‚£ç§é™æ€åˆ†é…æ–¹å¼ï¼Œå¦‚ICS09é‚£ç¯‡æ–‡ç« æ‰€è¿°çš„æ‰€æœ‰é™æ€åˆ†é…æ–¹å¼$/;"	m	struct:parameter_value
static_write	flash.c	/^static_write(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, struct sub_request *sub) {$/;"	f
statistic_output	ssd.c	/^void statistic_output(struct ssd_info *ssd) {$/;"	f
statisticfile	initialize.h	/^    FILE *statisticfile;$/;"	m	struct:ssd_info
statisticfile2	initialize.h	/^    FILE *statisticfile2;$/;"	m	struct:ssd_info
statisticfilename	initialize.h	/^    char statisticfilename[30];$/;"	m	struct:ssd_info
statisticfilename2	initialize.h	/^    char statisticfilename2[30];$/;"	m	struct:ssd_info
stored	initialize.h	/^    unsigned int stored;                \/\/indicate the sector is stored in buffer or not. 1 indicates the sector is stored and 0 indicate the sector isn't stored.EX.  00110011 indicates the first, second, fifth, sixth sector is stored in buffer.$/;"	m	struct:buffer_group
storedsub	initialize.h	/^struct sub_request *storedsub;          \/\/suspended write sub value$/;"	m	struct:chip_info	typeref:struct:chip_info::sub_request
striping	initialize.h	/^    int striping;                   \/\/è¡¨ç¤ºæ˜¯å¦ä½¿ç”¨äº†stripingæ–¹å¼ï¼Œ0è¡¨ç¤ºæ²¡æœ‰ï¼Œ1è¡¨ç¤ºæœ‰$/;"	m	struct:parameter_value
sub_page	initialize.h	/^    unsigned int sub_page;$/;"	m	struct:local
sub_request	initialize.h	/^struct sub_request {$/;"	s
subpage_capacity	initialize.h	/^    unsigned int subpage_capacity;$/;"	m	struct:parameter_value
subpage_num_page	initialize.h	/^    unsigned int subpage_num_page;      \/\/indicate how many subpage in a page$/;"	m	struct:chip_info
subpage_page	initialize.h	/^    unsigned int subpage_page;$/;"	m	struct:parameter_value
subs	initialize.h	/^    struct sub_request *subs;          \/\/é“¾æ¥åˆ°å±äºè¯¥è¯·æ±‚çš„æ‰€æœ‰å­è¯·æ±‚$/;"	m	struct:request	typeref:struct:request::sub_request
subs_r_head	initialize.h	/^    struct sub_request *subs_r_head;     \/\/channelä¸Šçš„è¯»è¯·æ±‚é˜Ÿåˆ—å¤´ï¼Œå…ˆæœåŠ¡å¤„äºé˜Ÿåˆ—å¤´çš„å­è¯·æ±‚$/;"	m	struct:channel_info	typeref:struct:channel_info::sub_request
subs_r_tail	initialize.h	/^    struct sub_request *subs_r_tail;     \/\/channelä¸Šçš„è¯»è¯·æ±‚é˜Ÿåˆ—å°¾ï¼Œæ–°åŠ è¿›æ¥çš„å­è¯·æ±‚åŠ åˆ°é˜Ÿå°¾$/;"	m	struct:channel_info	typeref:struct:channel_info::sub_request
subs_w_head	initialize.h	/^    struct sub_request *subs_w_head;     \/\/channelä¸Šçš„å†™è¯·æ±‚é˜Ÿåˆ—å¤´ï¼Œå…ˆæœåŠ¡å¤„äºé˜Ÿåˆ—å¤´çš„å­è¯·æ±‚$/;"	m	struct:channel_info	typeref:struct:channel_info::sub_request
subs_w_head	initialize.h	/^    struct sub_request *subs_w_head;     \/\/å½“é‡‡ç”¨å…¨åŠ¨æ€åˆ†é…æ—¶ï¼Œåˆ†é…æ˜¯ä¸çŸ¥é“åº”è¯¥æŒ‚è½½å“ªä¸ªchannelä¸Šï¼Œæ‰€ä»¥å…ˆæŒ‚åœ¨ssdä¸Šï¼Œç­‰è¿›å…¥processå‡½æ•°æ—¶æ‰æŒ‚åˆ°ç›¸åº”çš„channelçš„è¯»è¯·æ±‚é˜Ÿåˆ—ä¸Š$/;"	m	struct:ssd_info	typeref:struct:ssd_info::sub_request
subs_w_tail	initialize.h	/^    struct sub_request *subs_w_tail;     \/\/channelä¸Šçš„å†™è¯·æ±‚é˜Ÿåˆ—ï¼Œæ–°åŠ è¿›æ¥çš„å­è¯·æ±‚åŠ åˆ°é˜Ÿå°¾$/;"	m	struct:channel_info	typeref:struct:channel_info::sub_request
subs_w_tail	initialize.h	/^    struct sub_request *subs_w_tail;$/;"	m	struct:ssd_info	typeref:struct:ssd_info::sub_request
supply_voltage	initialize.h	/^    double supply_voltage;$/;"	m	struct:parameter_value
tADL	initialize.h	/^    int tADL;      \/\/address to data loading time$/;"	m	struct:ac_time_characteristics
tALH	initialize.h	/^    int tALH;      \/\/ALE hold time$/;"	m	struct:ac_time_characteristics
tALS	initialize.h	/^    int tALS;      \/\/ALE setup time$/;"	m	struct:ac_time_characteristics
tAR	initialize.h	/^    int tAR;       \/\/ALE to RE delay$/;"	m	struct:ac_time_characteristics
tAVLTree	avlTree.h	/^} tAVLTree;$/;"	t	typeref:struct:buffer_info
tBERS	initialize.h	/^    int tBERS;     \/\/block erase time$/;"	m	struct:ac_time_characteristics
tCEA	initialize.h	/^    int tCEA;      \/\/CE access time$/;"	m	struct:ac_time_characteristics
tCH	initialize.h	/^    int tCH;       \/\/CE hold time$/;"	m	struct:ac_time_characteristics
tCHZ	initialize.h	/^    int tCHZ;      \/\/CE high to output hi-z$/;"	m	struct:ac_time_characteristics
tCLH	initialize.h	/^    int tCLH;      \/\/CLE hold time$/;"	m	struct:ac_time_characteristics
tCLR	initialize.h	/^    int tCLR;      \/\/CLE to RE delay$/;"	m	struct:ac_time_characteristics
tCLS	initialize.h	/^    int tCLS;      \/\/CLE setup time$/;"	m	struct:ac_time_characteristics
tCOH	initialize.h	/^    int tCOH;      \/\/CE high to output hold$/;"	m	struct:ac_time_characteristics
tCS	initialize.h	/^    int tCS;       \/\/CE setup time$/;"	m	struct:ac_time_characteristics
tDBSY	initialize.h	/^    int tDBSY;     \/\/bummy busy time for two-plane program$/;"	m	struct:ac_time_characteristics
tDH	initialize.h	/^    int tDH;       \/\/data hold time$/;"	m	struct:ac_time_characteristics
tDS	initialize.h	/^    int tDS;       \/\/data setup time$/;"	m	struct:ac_time_characteristics
tIR	initialize.h	/^    int tIR;       \/\/output hi-z to RE low$/;"	m	struct:ac_time_characteristics
tPROG	initialize.h	/^    int tPROG;     \/\/program time   coarse partical size$/;"	m	struct:ac_time_characteristics
tPROG_Nw_cycle	initialize.h	/^    int tPROG_Nw_cycle;     \/\/ ISPP iterations number. Here is 5$/;"	m	struct:ac_time_characteristics
tPROG_Tw_cycle	initialize.h	/^    int tPROG_Tw_cycle;     \/\/ one iterations consisting of tPROG_w_program + tPROG_w_verify (32+8)us. $/;"	m	struct:ac_time_characteristics
tPROG_buffer	initialize.h	/^    int tPROG_buffer;       \/\/ the time taken to load the page buffer with data.$/;"	m	struct:ac_time_characteristics
tPROG_r_phy	initialize.h	/^    int tPROG_r_phy;        \/\/ here is normal read + read_extra in suspension.but this design will not use average value for we can $/;"	m	struct:ac_time_characteristics
tPROG_w_progam	initialize.h	/^    int tPROG_w_progam;     \/\/ the flash program time in one iterations $/;"	m	struct:ac_time_characteristics
tPROG_w_total	initialize.h	/^    int tPROG_w_total;      \/\/ Total program time\/Nw_cycle. Here is 40us$/;"	m	struct:ac_time_characteristics
tPROG_w_verify	initialize.h	/^    int tPROG_w_verify;     \/\/ verify the program result in flash. acturally it is the same to tERSE_verify $/;"	m	struct:ac_time_characteristics
tR	initialize.h	/^    int tR;        \/\/data transfer from cell to register$/;"	m	struct:ac_time_characteristics
tRC	initialize.h	/^    int tRC;       \/\/read cycle time$/;"	m	struct:ac_time_characteristics
tREA	initialize.h	/^    int tREA;      \/\/RE access time$/;"	m	struct:ac_time_characteristics
tREH	initialize.h	/^    int tREH;      \/\/RE high to output time$/;"	m	struct:ac_time_characteristics
tRHOH	initialize.h	/^    int tRHOH;     \/\/RE high to output hold$/;"	m	struct:ac_time_characteristics
tRHW	initialize.h	/^    int tRHW;      \/\/RE high to WE low$/;"	m	struct:ac_time_characteristics
tRHZ	initialize.h	/^    int tRHZ;      \/\/RE high to output hi-z$/;"	m	struct:ac_time_characteristics
tRLOH	initialize.h	/^    int tRLOH;     \/\/RE low to output hold$/;"	m	struct:ac_time_characteristics
tRP	initialize.h	/^    int tRP;       \/\/RE pulse width$/;"	m	struct:ac_time_characteristics
tRR	initialize.h	/^    int tRR;       \/\/ready to RE low$/;"	m	struct:ac_time_characteristics
tRST	initialize.h	/^    int tRST;      \/\/device resetting time$/;"	m	struct:ac_time_characteristics
tWB	initialize.h	/^    int tWB;       \/\/WE high to busy$/;"	m	struct:ac_time_characteristics
tWC	initialize.h	/^    int tWC;       \/\/write cycle time$/;"	m	struct:ac_time_characteristics
tWH	initialize.h	/^    int tWH;       \/\/WE high hold time$/;"	m	struct:ac_time_characteristics
tWHR	initialize.h	/^    int tWHR;      \/\/WE high to RE low$/;"	m	struct:ac_time_characteristics
tWP	initialize.h	/^    int tWP;       \/\/WE pulse width$/;"	m	struct:ac_time_characteristics
threshold_fixed_adjust	initialize.h	/^    int threshold_fixed_adjust;$/;"	m	struct:parameter_value
threshold_value	initialize.h	/^    int threshold_value;$/;"	m	struct:parameter_value
time	initialize.h	/^    int64_t time;                      \/\/è¯·æ±‚åˆ°è¾¾çš„æ—¶é—´ï¼Œå•ä½ä¸ºus,è¿™é‡Œå’Œé€šå¸¸çš„ä¹ æƒ¯ä¸ä¸€æ ·ï¼Œé€šå¸¸çš„æ˜¯msä¸ºå•ä½ï¼Œè¿™é‡Œéœ€è¦æœ‰ä¸ªå•ä½å˜æ¢è¿‡ç¨‹$/;"	m	struct:request
time_characteristics	initialize.h	/^    struct ac_time_characteristics time_characteristics;$/;"	m	struct:parameter_value	typeref:struct:parameter_value::ac_time_characteristics
time_step	initialize.h	/^    unsigned int time_step;$/;"	m	struct:parameter_value
token	initialize.h	/^    unsigned int token;                  \/\/åœ¨åŠ¨æ€åˆ†é…ä¸­ï¼Œä¸ºé˜²æ­¢æ¯æ¬¡åˆ†é…åœ¨ç¬¬ä¸€ä¸ªchanneléœ€è¦ç»´æŒä¸€ä¸ªä»¤ç‰Œï¼Œæ¯æ¬¡ä»ä»¤ç‰Œæ‰€æŒ‡çš„ä½ç½®å¼€å§‹åˆ†é…$/;"	m	struct:ssd_info
token	initialize.h	/^    unsigned int token;                  \/\/åœ¨åŠ¨æ€åˆ†é…ä¸­ï¼Œä¸ºé˜²æ­¢æ¯æ¬¡åˆ†é…åœ¨ç¬¬ä¸€ä¸ªchipéœ€è¦ç»´æŒä¸€ä¸ªä»¤ç‰Œï¼Œæ¯æ¬¡ä»ä»¤ç‰Œæ‰€æŒ‡çš„ä½ç½®å¼€å§‹åˆ†é…$/;"	m	struct:channel_info
token	initialize.h	/^    unsigned int token;                 \/\/åœ¨åŠ¨æ€åˆ†é…ä¸­ï¼Œä¸ºé˜²æ­¢æ¯æ¬¡åˆ†é…åœ¨ç¬¬ä¸€ä¸ªdieéœ€è¦ç»´æŒä¸€ä¸ªä»¤ç‰Œï¼Œæ¯æ¬¡ä»ä»¤ç‰Œæ‰€æŒ‡çš„ä½ç½®å¼€å§‹åˆ†é…$/;"	m	struct:chip_info
token	initialize.h	/^    unsigned int token;                 \/\/åœ¨åŠ¨æ€åˆ†é…ä¸­ï¼Œä¸ºé˜²æ­¢æ¯æ¬¡åˆ†é…åœ¨ç¬¬ä¸€ä¸ªplaneéœ€è¦ç»´æŒä¸€ä¸ªä»¤ç‰Œï¼Œæ¯æ¬¡ä»ä»¤ç‰Œæ‰€æŒ‡çš„ä½ç½®å¼€å§‹åˆ†é…$/;"	m	struct:die_info
trace_assert	pagemap.c	/^void trace_assert(int64_t time_t, int device, unsigned int lsn, int size, int ope)\/\/æ–­è¨€$/;"	f
trace_output	ssd.c	/^void trace_output(struct ssd_info *ssd) {$/;"	f
tracefile	initialize.h	/^    FILE *tracefile;$/;"	m	struct:ssd_info
tracefilename	initialize.h	/^    char tracefilename[30];$/;"	m	struct:ssd_info
transfer_size	ssd.c	/^unsigned int transfer_size(struct ssd_info *ssd, int need_distribute, unsigned int lpn, struct request *req) {$/;"	f
tree_root	avlTree.h	/^    struct _AVL_TREE_NODE *tree_root;$/;"	m	struct:_AVL_TREE_NODE	typeref:struct:_AVL_TREE_NODE::_AVL_TREE_NODE
try_to_restore_gc_function	flash.c	/^int try_to_restore_gc_function(struct ssd_info *ssd, struct gc_operation *gc_node, unsigned int channel, unsigned int chip)$/;"	f
try_to_restore_write_function	flash.c	/^int try_to_restore_write_function(struct ssd_info *ssd){$/;"	f
type	initialize.h	/^    int type;                        \/\/è®°å½•è¯¥äº‹ä»¶çš„ç±»å‹ï¼Œ1è¡¨ç¤ºå‘½ä»¤ç±»å‹ï¼Œ2è¡¨ç¤ºæ•°æ®ä¼ è¾“ç±»å‹$/;"	m	struct:event_node
un_greed_copyback	flash.c	/^struct ssd_info *un_greed_copyback(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die,$/;"	f
un_greed_interleave_copyback	flash.c	/^un_greed_interleave_copyback(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die,$/;"	f
uninterrupt_gc	pagemap.c	/^uninterrupt_gc(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane) {$/;"	f
update	initialize.h	/^    struct sub_request *update;       \/\/å› ä¸ºåœ¨å†™æ“ä½œä¸­å­˜åœ¨æ›´æ–°æ“ä½œï¼Œå› ä¸ºåœ¨åŠ¨æ€åˆ†é…æ–¹å¼ä¸­æ— æ³•ä½¿ç”¨copybackæ“ä½œï¼Œéœ€è¦å°†åŸæ¥çš„é¡µè¯»å‡ºåæ‰èƒ½è¿›è¡Œå†™æ“ä½œï¼Œæ‰€ä»¥ï¼Œå°†å› æ›´æ–°äº§ç”Ÿçš„è¯»æ“ä½œæŒ‚åœ¨è¿™ä¸ªæŒ‡é’ˆä¸Š$/;"	m	struct:sub_request	typeref:struct:sub_request::sub_request
update_read_count	initialize.h	/^    unsigned int update_read_count;      \/\/è®°å½•å› ä¸ºæ›´æ–°æ“ä½œå¯¼è‡´çš„é¢å¤–è¯»å‡ºæ“ä½œ$/;"	m	struct:ssd_info
valid_state	initialize.h	/^    int valid_state;                   \/\/indicate the page is valid or invalid$/;"	m	struct:page_info
victim_block_freepage_statistic	initialize.h	/^        unsigned int victim_block_freepage_statistic;$/;"	m	struct:gc_operation
victim_block_number	initialize.h	/^        unsigned int victim_block_number;$/;"	m	struct:gc_operation
voltage	initialize.h	/^    float voltage;$/;"	m	struct:dram_parameter
waste_page_count	initialize.h	/^    unsigned long waste_page_count;      \/\/è®°å½•å› ä¸ºé«˜çº§å‘½ä»¤çš„é™åˆ¶å¯¼è‡´çš„é¡µæµªè´¹$/;"	m	struct:ssd_info
wear_leveling	initialize.h	/^    int wear_leveling;              \/\/ WLç®—æ³•$/;"	m	struct:parameter_value
write	initialize.h	/^        unsigned int write;$/;"	m	struct:gc_operation
write_avg	initialize.h	/^    int64_t write_avg;                   \/\/è®°å½•ç”¨äºè®¡ç®—å†™è¯·æ±‚å¹³å‡å“åº”æ—¶é—´çš„æ—¶é—´$/;"	m	struct:ssd_info
write_flash_count	initialize.h	/^    unsigned long write_flash_count;     \/\/å®é™…äº§ç”Ÿçš„å¯¹flashçš„å†™æ“ä½œ$/;"	m	struct:ssd_info
write_hit	avlTree.h	/^    unsigned long write_hit;$/;"	m	struct:buffer_info
write_miss_hit	avlTree.h	/^    unsigned long write_miss_hit;$/;"	m	struct:buffer_info
write_page	flash.c	/^Status write_page(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane,$/;"	f
write_preemptive_sign	initialize.h	/^int write_preemptive_sign; \/\/ 1 means the preemptive process sign.$/;"	m	struct:chip_info
write_request_count	initialize.h	/^    unsigned int write_request_count;    \/\/è®°å½•å†™æ“ä½œçš„æ¬¡æ•°$/;"	m	struct:ssd_info
write_suspend_doing	initialize.h	/^unsigned int write_suspend_doing;$/;"	m	struct:ssd_info
write_suspend_times	initialize.h	/^unsigned int write_suspend_times;\/\/ statistic for write suspend times.$/;"	m	struct:ssd_info
written_count	initialize.h	/^    unsigned int written_count;        \/\/è®°å½•è¯¥é¡µè¢«å†™çš„æ¬¡æ•°$/;"	m	struct:page_info
zt	Session.vim	/^normal! zt$/;"	m
